\chapter{PCF and its operational semantics}

\section{PCF}

\begin{definition}[Types of PCF, \(\pcfnat\), \(\sigma \pcffun \tau\)]
  The \emph{types of PCF} are inductively defined as:
  \begin{enumerate}[(i)]
  \item \(\pcfnat\) is the \emph{base type} of PCF, and
  \item if \(\sigma\) and \(\tau\) are types of PCF, then we have the
    \emph{function type} \(\sigma \pcffun \tau\).
  \end{enumerate}
\end{definition}

\begin{definition}[Typing rules of PCF, \(\Gamma \vdash M : \sigma\)]
  We inductively define when a \emph{term~\(M\) has type \(\sigma\) in context
    \(\Gamma\)}, written \(\Gamma \vdash M : \sigma\), by the following
  inductive clauses:
  %

  \begin{center}
  \def\fCenter{\ \vdash\ }

  \AxiomC{}
  \UnaryInf$\Gamma,\var{x}:\sigma,\Delta \fCenter \var{x} : \sigma$
  \DisplayProof\hspace{3cm}
  \Axiom$\Gamma , \var{x} : \sigma \fCenter M : \tau$
  \UnaryInf$\Gamma \fCenter (\lambdadot{\var{x} : \sigma}{M}) : \sigma \pcffun \tau$
  \DisplayProof\vspace{1cm}\\
  \Axiom$\Gamma \fCenter M : \sigma \pcffun \tau$
  \Axiom$\Gamma \fCenter N : \sigma$
  \BinaryInf$\Gamma \fCenter M(N) : \tau$
  \DisplayProof\hspace{3cm}
  \Axiom$\Gamma \fCenter M : \sigma \pcffun \sigma$
  \UnaryInf$\Gamma \fCenter \fix_\sigma(M) : \sigma$
  \DisplayProof\vspace{1cm}\\
  \AxiomC{}
  \UnaryInf$\Gamma \fCenter \pcfzero : \pcfnat$
  \DisplayProof\quad\quad\quad
  \Axiom$\Gamma \fCenter M : \pcfnat$
  \UnaryInf$\Gamma \fCenter \pcfsuc(M) : \pcfnat$
  \DisplayProof\quad\quad\quad
  \Axiom$\Gamma \fCenter M : \pcfnat$
  \UnaryInf$\Gamma \fCenter \pcfpred(M) : \pcfnat$
  \DisplayProof\vspace{1cm}\\
  \Axiom$\Gamma \fCenter M : \pcfnat$
  \Axiom$\Gamma \fCenter N : \pcfnat$
  \Axiom$\Gamma \fCenter K : \pcfnat$
  \TrinaryInf$\Gamma \fCenter \pcfifz(M,N,K) : \pcfnat$
  \DisplayProof
  \end{center}
\end{definition}

\begin{definition}[Numeral, \(\numeral{n}\)]
  For a natural number \(n \in \Nat\), we define the
  \emph{numeral}~\(\numeral n\) in PCF inductively:
  \(\numeral 0 \coloneqq \pcfzero\) and
  \(\numeral{m+1} \coloneqq \pcfsuc(\numeral m)\).
\end{definition}

\begin{example}
  We can translate the programme \verb|if (x+1 == 0) then 5 else 3|, written in
  pseudocode, to the PCF programme
  \(\lambdadot{\var x : \pcfnat}{\pcfifz(\pcfsuc(\var x),\numeral 5,\numeral 3)}\).
\end{example}

\begin{example}[Addition by \(n\) in PCF]
  For a natural number \(n \in \Nat\), consider addition by \(n\) as a
  recursively defined function:
  \begin{alignat*}{3}
    &\add_n : \Nat \to && \Nat && \\
    &\add_n(0) &&\coloneqq n, && \\
    &\add_n(k+1) &&\coloneqq \add_n(k) + 1. &&
  \end{alignat*}
  We show how to write this function as a PCF programme. We start by slightly
  rewriting \(\add_n\) as:
  \begin{equation*}\label{add_n-alt}\tag{\(\ast\)}
    \add_n(m) \coloneqq
    \begin{cases}
      n &\text{if } m = 0, \\
      \suc\pa*{\add_n(\pred(m))} &\text{else}.
    \end{cases}
  \end{equation*}
  Looking at the above, we see that we have most of the analogues readily
  available in PCF: \(\pcfifz\), \(\pcfsuc\) and \(\pcfpred\), as well as the
  numeral \(\underline n\).

  We next define the programme
  \(t : \pa*{\pcfnat \pcffun \pcfnat} \pcffun \pa*{\pcfnat \pcffun \pcfnat}\) as
  follows:
  \[
    t \coloneqq \lambdadot{\var x : \pa{\pcfnat \pcffun
        \pcfnat}}{\lambdadot{\var y : \pcfnat}%
      {\pcfifz\pa*{\var y,\numeral{n},%
          \pcfsuc\pa*{\var x\pa*{\pcfpred \, \var y }}}}}.
  \]
  In the programme \(t\), the variable \(\var y\) plays the role of \(m\) in
  \eqref{add_n-alt} and \(\var x\) is like a placeholder for the recursive call.

  Mirroring~\eqref{add_n-alt} further, roughly what we want is a programme
  \(f : \pcfnat \pcffun \pcfnat\) such that the ``equation''
  \(f = t\,f\) holds. That is, we want a \emph{fixed point} of \(t\).
  %
  Hence, we finally define \(\pcfadd_n\) as:
  \[
    \pcfadd_n \coloneqq \fix_{\pcfnat \pcffun \pcfnat}(t).
  \]
  % \[
  %   \fix_{\pcfnat \pcffun \pcfnat} : \pa*{\pa*{\pcfnat \pcffun \pcfnat}
  %     \pcffun \pa*{\pcfnat \pcffun \pcfnat}} \pcffun \pa{\pcfnat \pcffun \pcfnat}.
  % \]
\end{example}

\begin{exercise}\label{exer:pcf-add-mult}
  Construct PCF programmes
  \(\pcfadd,\pcffont{mult} : \pcfnat \pcffun \pcfnat \pcffun \pcfnat\)
  implementing addition and multiplication, respectively.
\end{exercise}

\section{Operational semantics}

\subsection{Small-step operational semantics}

\subsection{Big-step operational semantics}

\section{List of exercises}
\begin{enumerate}
\item \cref{exer:pcf-add-mult}: On defining addition and multiplication in PCF.
\end{enumerate}




%%% Local Variables:
%%% mode: latexmk
%%% TeX-master: "../main"
%%% End:
