\chapter{PCF and its operational semantics}

\section{PCF}

\begin{definition}[Types of PCF, \(\pcfnat\), \(\sigma \pcffun \tau\)]
  The \emph{types of PCF} are inductively defined as:
  \begin{enumerate}[(i)]
  \item \(\pcfnat\) is the \emph{base type} of PCF, and
  \item if \(\sigma\) and \(\tau\) are types of PCF, then we have the
    \emph{function type} \(\sigma \pcffun \tau\).
  \end{enumerate}
\end{definition}

\begin{definition}[Typing rules of PCF, \(\Gamma \vdash M : \sigma\)]
  We inductively define when a \emph{term~\(M\) has type \(\sigma\) in context
    \(\Gamma\)}, written \(\Gamma \vdash M : \sigma\), by the following
  inductive clauses:
  \begin{center}
  \def\fCenter{\ \vdash\ }

  \AxiomC{\phantom{$\fCenter$}}
  \UnaryInf$\Gamma,\var{x}:\sigma,\Delta \fCenter \var{x} : \sigma$
  \DisplayProof\hspace{3cm}
  \Axiom$\Gamma , \var{x} : \sigma \fCenter M : \tau$
  \UnaryInf$\Gamma \fCenter (\lambdadot{\var{x} : \sigma}{M}) : \sigma \pcffun \tau$
  \DisplayProof\vspace{1cm}\\
  \Axiom$\Gamma \fCenter M : \sigma \pcffun \tau$
  \Axiom$\Gamma \fCenter N : \sigma$
  \BinaryInf$\Gamma \fCenter M(N) : \tau$
  \DisplayProof\hspace{3cm}
  \Axiom$\Gamma \fCenter M : \sigma \pcffun \sigma$
  \UnaryInf$\Gamma \fCenter \fix_\sigma(M) : \sigma$
  \DisplayProof\vspace{1cm}\\
  \AxiomC{}
  \UnaryInf$\Gamma \fCenter \pcfzero : \pcfnat$
  \DisplayProof\quad\quad\quad
  \Axiom$\Gamma \fCenter M : \pcfnat$
  \UnaryInf$\Gamma \fCenter \pcfsuc(M) : \pcfnat$
  \DisplayProof\quad\quad\quad
  \Axiom$\Gamma \fCenter M : \pcfnat$
  \UnaryInf$\Gamma \fCenter \pcfpred(M) : \pcfnat$
  \DisplayProof\vspace{1cm}\\
  \Axiom$\Gamma \fCenter M : \pcfnat$
  \Axiom$\Gamma \fCenter N_1 : \pcfnat$
  \Axiom$\Gamma \fCenter N_2 : \pcfnat$
  \TrinaryInf$\Gamma \fCenter \pcfifz(M,N_1,N_2) : \pcfnat$
  \DisplayProof
  \end{center}
\end{definition}

\begin{definition}[Numeral, \(\numeral{n}\)]
  For a natural number \(n \in \Nat\), we define the
  \emph{numeral}~\(\numeral n\) in PCF inductively:
  \(\numeral 0 \coloneqq \pcfzero\) and
  \(\numeral{m+1} \coloneqq \pcfsuc(\numeral m)\).
\end{definition}

\begin{example}
  We can translate the programme \verb|if (x+1 == 0) then 5 else 3|, written in
  pseudocode, to the PCF programme
  \(\lambdadot{\var x : \pcfnat}{\pcfifz(\pcfsuc(\var x),\numeral 5,\numeral 3)}\).
\end{example}

\begin{example}[Addition by \(n\) in PCF]
  For a natural number \(n \in \Nat\), consider addition by \(n\) as a
  recursively defined function:
  \begin{alignat*}{3}
    &\add_n : \Nat \to && \Nat && \\
    &\add_n(0) &&\coloneqq n, && \\
    &\add_n(k+1) &&\coloneqq \add_n(k) + 1. &&
  \end{alignat*}
  We show how to write this function as a PCF programme. We start by slightly
  rewriting \(\add_n\) as:
  \begin{equation*}\label{add_n-alt}\tag{\(\ast\)}
    \add_n(m) \coloneqq
    \begin{cases}
      n &\text{if } m = 0, \\
      \suc\pa*{\add_n(\pred(m))} &\text{else}.
    \end{cases}
  \end{equation*}
  Looking at the above, we see that we have most of the analogues readily
  available in PCF: \(\pcfifz\), \(\pcfsuc\) and \(\pcfpred\), as well as the
  numeral \(\underline n\).

  We next define the programme
  \(F : \pa*{\pcfnat \pcffun \pcfnat} \pcffun \pa*{\pcfnat \pcffun \pcfnat}\) as
  follows:
  \[
    F \coloneqq \lambdadot{\var x : \pa{\pcfnat \pcffun
        \pcfnat}}{\lambdadot{\var y : \pcfnat}%
      {\pcfifz\pa*{\var y,\numeral{n},%
          \pcfsuc\pa*{\var x\pa*{\pcfpred \, \var y }}}}}.
  \]
  In the programme \(F\), the variable \(\var y\) plays the role of \(m\) in
  \eqref{add_n-alt} and \(\var x\) is like a placeholder for the recursive call.

  Mirroring~\eqref{add_n-alt} further, roughly what we want is a programme
  \(f : \pcfnat \pcffun \pcfnat\) such that the ``equation''
  \(f = F\,f\) holds. That is, we want a \emph{fixed point} of \(F\).
  %
  Hence, we finally define \(\pcfadd_n\) as:
  \[
    \pcfadd_n \coloneqq \fix_{\pcfnat \pcffun \pcfnat}(F).
  \]
  % \[
  %   \fix_{\pcfnat \pcffun \pcfnat} : \pa*{\pa*{\pcfnat \pcffun \pcfnat}
  %     \pcffun \pa*{\pcfnat \pcffun \pcfnat}} \pcffun \pa{\pcfnat \pcffun \pcfnat}.
  % \]
\end{example}

\begin{exercise}\label{exer:pcf-add-mult}
  Construct PCF programmes
  \(\pcfadd,\pcffont{mult} : \pcfnat \pcffun \pcfnat \pcffun \pcfnat\)
  implementing addition and multiplication, respectively.
\end{exercise}

%\section{Operational semantics}

%\subsection{Small-step operational semantics}

\begin{definition}[Small-step operational semantics of PCF, \(M \smallstep N\)]
  We inductively define when a term \(M\) \emph{(small-step) reduces} to another
  term \(N\) (of the same type), written \(M \smallstep N\), by the following
  inductive clauses:
  \begin{center}
  \AxiomC{\phantom{${\smallstep}$}}
  \UnaryInfC{\((\lambdadot{\var x : \sigma}{M})N \smallstep M[N/x]\)}
  \DisplayProof\quad\quad\quad
  \AxiomC{\phantom{${\smallstep}$}}
  \UnaryInfC{\(\fix_\sigma(M) \smallstep M\pa*{\fix_\sigma(M)}\)}
  \DisplayProof\vspace{1cm}\\
  \AxiomC{\phantom{${\smallstep}$}}
  \UnaryInfC{\(\pcfpred(\numeral 0) \smallstep \numeral 0\)}
  \DisplayProof\quad\quad\quad
  \AxiomC{\phantom{${\smallstep}$}}
  \UnaryInfC{\(\pcfpred(\numeral{n+1}) \smallstep \numeral n\)}
  \DisplayProof\vspace{1cm}\\
  \AxiomC{\phantom{${\smallstep}$}}
  \UnaryInfC{\(\pcfifz(\numeral 0,M,N) \smallstep M\)}
  \DisplayProof\quad\quad\quad
  \AxiomC{\phantom{${\smallstep}$}}
  \UnaryInfC{\(\pcfifz(\numeral {n+1},M,N) \smallstep N\)}
  \DisplayProof\vspace{1cm}\\
  %
  \AxiomC{\(M_1 \smallstep M_2\)}
  \UnaryInfC{\(M_1(N) \smallstep M_2(N)\)}
  \DisplayProof\quad\quad\quad
  %
  \AxiomC{\(M_1 \smallstep M_2\)}
  \UnaryInfC{\(\pcfsuc(M_1) \smallstep \pcfsuc(M_2)\)}
  \DisplayProof\vspace{1cm}\\
  \AxiomC{\(M_1 \smallstep M_2\)}
  \UnaryInfC{\(\pcfpred(M_1) \smallstep \pcfpred(M_2)\)}
  \DisplayProof\quad\quad\quad
  \AxiomC{\(M_1 \smallstep M_2\)}
  \UnaryInfC{\(\pcfifz(M_1,N_1,N_2) \smallstep \pcfifz(M_2,N_1,N_2)\)}
  \DisplayProof
  \end{center}
\end{definition}

\section{Big-step operational semantics}

\begin{definition}[Big-step operational semantics of PCF, \(M \bigstep V\)]
  We inductively define when a term \(M\) \emph{(big-step) reduces} to a value
  \(V\), written \(M \bigstep V\), by the following inductive clauses:
  \begin{center}
  \AxiomC{\phantom{${\bigstep}$}}
  \UnaryInfC{\(\var x \bigstep \var x\)}
  \DisplayProof\quad\quad\quad\quad\quad\quad\quad
  \AxiomC{\phantom{${\bigstep}$}}
  \UnaryInfC{\(\lambdadot{\var x : \sigma}{M} \bigstep \lambdadot{\var x : \sigma}{M}\)}
  \DisplayProof\vspace{1cm}\\
  \AxiomC{\(M \bigstep \lambdadot{\var x : \sigma}{E}\)}
  \AxiomC{\(E[N/x] \bigstep V\)}
  \BinaryInfC{\(M(N) \bigstep V\)}
  \DisplayProof\quad\quad\quad
  \AxiomC{\(M(\fix_{\sigma}(M)) \bigstep V\)}
  \UnaryInfC{\(\fix_{\sigma}(M) \bigstep V\)}
  \DisplayProof\vspace{1cm}\\
  \AxiomC{\phantom{${\bigstep}$}}
  \UnaryInfC{\(\numeral 0 \bigstep \numeral 0\)}
  \DisplayProof\quad\quad\quad
  \AxiomC{\(M \bigstep \numeral{n}\)}
  \UnaryInfC{\(\pcfsuc(M) \bigstep \numeral{n+1}\)}
  \DisplayProof\vspace{1cm}\\
  \AxiomC{\(M \bigstep \numeral 0\)}
  \UnaryInfC{\(\pcfpred(M) \bigstep \numeral 0\)}
  \DisplayProof\quad\quad\quad
  %
  \AxiomC{\(M \bigstep \numeral {n+1}\)}
  \UnaryInfC{\(\pcfpred(M) \bigstep \numeral n\)}
  \DisplayProof\vspace{1cm}\\
  \AxiomC{\(M \bigstep \numeral 0\)}
  \AxiomC{\(N_1 \bigstep V\)}
  \BinaryInfC{\(\pcfifz(M,N_1,N_2) \bigstep V\)}
  \DisplayProof\quad\quad\quad
  \AxiomC{\(M \bigstep \numeral {n+1}\)}
  \AxiomC{\(N_2 \bigstep V\)}
  \BinaryInfC{\(\pcfifz(M,N_1,N_2) \bigstep V\)}
  \DisplayProof
  \end{center}
\end{definition}

\section{List of exercises}
\begin{enumerate}
\item \cref{exer:pcf-add-mult}: On defining addition and multiplication in PCF.
\end{enumerate}




%%% Local Variables:
%%% mode: latexmk
%%% TeX-master: "../main"
%%% End:
